{"version":3,"file":"index.min.js","sources":["../src/index.ts"],"sourcesContent":["import WDIOReporter, { TestStats } from '@wdio/reporter';\nimport { Frameworks, Services } from '@wdio/types';\nimport {\n  APPLAUSE_LOG_RECORDS,\n  ApplauseConfig,\n  ApplauseReporter,\n  AssetType,\n  constructDefaultLogger,\n  loadConfig,\n  parseTestCaseName,\n  PublicApi,\n  TestResultStatus,\n  TestRunAutoResultStatus,\n} from 'applause-reporter-common';\nimport * as winston from 'winston';\n\nexport class ApplauseRunService implements Services.ServiceInstance {\n  reporter: ApplauseReporter;\n  logger: winston.Logger;\n\n  constructor(serviceOptions: Services.ServiceOption) {\n    this.logger =\n      (serviceOptions['logger'] as winston.Logger) || constructDefaultLogger();\n    this.reporter = new ApplauseReporter(\n      loadConfig(serviceOptions),\n      this.logger\n    );\n  }\n\n  async onPrepare() {\n    const testRunId = await this.reporter.runnerStart();\n    process.env['APPLAUSE_RUN_ID'] = `${testRunId}`;\n  }\n\n  async onComplete() {\n    await this.reporter.runnerEnd();\n  }\n}\n\nexport class ApplauseResultService implements Services.ServiceInstance {\n  reporter: ApplauseReporter;\n  logger: winston.Logger;\n  activeTest?: string;\n\n  constructor(serviceOptions: Services.ServiceOption) {\n    this.logger =\n      (serviceOptions['logger'] as winston.Logger) || constructDefaultLogger();\n    this.reporter = new ApplauseReporter(\n      loadConfig(serviceOptions),\n      this.logger\n    );\n  }\n\n  /**\n   * Before test hook. This is called for tests executed by the Mocha or Jasmine framework. See beforeScenario for\n   * execution of Cucumber tests.\n   *\n   * @param test The test object\n   */\n  async beforeTest(test: Frameworks.Test) {\n    const title = this.lookupTitle(test);\n    this.logger.info('Starting test: ' + title);\n    this.activeTest = title;\n    await this.reporter.startTestCase(title, title, {\n      providerSessionIds: [],\n    });\n  }\n\n  /**\n   * The beforeScenario hook is called before each scenario in a Cucumber test.\n   *\n   * @param world The cucumber world object\n   */\n  async beforeScenario(world: Frameworks.World) {\n    const title = this.lookupTitle(world);\n    this.logger.info('Starting Scenario: ' + title);\n    this.activeTest = title;\n    await this.reporter.startTestCase(title, title, {\n      providerSessionIds: [],\n    });\n  }\n\n  async afterCommand(\n    commandName: string,\n    args: unknown[],\n    result: unknown\n  ): Promise<void> {\n    if (!this.activeTest) {\n      return;\n    }\n    if (commandName.startsWith('saveScreenshot')) {\n      const screenshotName =\n        (args[0] as string).split('/').pop() || 'screenshot.png';\n      this.logger.debug('Capturing screenshot');\n      await this.reporter.attachTestCaseAsset(\n        this.activeTest,\n        screenshotName,\n        browser.sessionId,\n        AssetType.SCREENSHOT,\n        Buffer.from(result as string, 'base64')\n      );\n    }\n  }\n\n  /**\n   * The afterTest hook is called after each test in a Mocha or Jasmine test.\n   *\n   * @param test The test object\n   * @param _context The context object\n   * @param result The result object\n   */\n  async afterTest(\n    test: Frameworks.Test,\n    _context: unknown,\n    result: Frameworks.TestResult\n  ) {\n    this.activeTest = undefined;\n    const title = this.lookupTitle(test);\n    \n    const errorMessage: string | undefined  = result.error?.message || result.exception;\n\n    let status: TestResultStatus;\n    if (result.passed) {\n      this.logger.info('Test Passed: ' + title + ' (' + browser.sessionId + ')');\n      status = TestResultStatus.PASSED;\n    } else if (test.pending || result.error instanceof ApplauseSkip) {\n      this.logger.warn('Test Skipped: ' + title);\n      status = TestResultStatus.SKIPPED;\n    } else {\n      this.logger.error('Test Failed: ' + title);\n      status = TestResultStatus.FAILED;\n    }\n\n    await this.reporter.submitTestCaseResult(\n      title,\n      status,\n      {\n        failureReason: this.cleanErrorMessage(errorMessage),\n        providerSessionGuids: [browser.sessionId],\n      }\n    );\n    await this.captureAssets(title, result.passed);\n  }\n\n  /**\n   * The afterScenario hook is called after each scenario in a Cucumber test.\n   *\n   * @param world The cucumber world object\n   * @param result The result object\n   */\n  async afterScenario(world: Frameworks.World, result: Frameworks.TestResult) {\n    this.activeTest = undefined;\n    const title = this.lookupTitle(world);\n    const errorMessage: string | undefined  = result.error?.message || result.exception;\n\n    let status: TestResultStatus;\n    if (result.passed) {\n      this.logger.info('Test Passed: ' + title + ' (' + browser.sessionId + ')');\n      status = TestResultStatus.PASSED;\n    } else if (result.error instanceof ApplauseSkip) {\n      this.logger.info('Test Skipped: ' + title);\n      status = TestResultStatus.SKIPPED;\n    } else {\n      this.logger.error('Test Failed: ' + title);\n      status = TestResultStatus.FAILED;\n    }\n    await this.reporter.submitTestCaseResult(\n      title,\n      status,\n      {\n        failureReason: this.cleanErrorMessage(errorMessage),\n        providerSessionGuids: [browser.sessionId],\n      }\n    );\n    await this.captureAssets(title, result.passed);\n  }\n\n  /**\n   * Function to lookup the title from a Test or World object. WebdriverIO is inconsistent with where the title is stored. In some\n   * cases it is in the `fullName` property, in others it is in the `fullTitle` property, and in others it is in the `title` property.\n   * For cucumber, it is stored in the `pickle.name` property. If none of these are found, it will return '<Unknown Test>'.\n   *\n   * @param test The test or world object\n   * @returns The title of the test\n   */\n  private lookupTitle(\n    test: Partial<Frameworks.Test & Frameworks.World>\n  ): string {\n    if (test.fullName) {\n      return test.fullName;\n    }\n    if (test.fullTitle) {\n      return test.fullTitle;\n    }\n    if (!!test.parent && !!test.title) {\n      return test.parent + ' ' + test.title;\n    }\n    if (!!test.pickle && !!test.pickle.name) {\n      return test.pickle.name;\n    }\n    return '<Unknown Test>';\n  }\n\n  /**\n   * Function to capture assets for a test case. This includes a screenshot, page source, and console log. If the test case failed,\n   * the failure screenshot will be attached to the test case.\n   *\n   * @param resultId The result ID of the test case\n   * @param passed Whether the test case passed\n   */\n  private async captureAssets(\n    resultId: string,\n    passed: boolean\n  ): Promise<void> {\n    const assetsToUpload: [string, AssetType, Buffer][] = [];\n    try {\n      if (!passed) {\n        const screenshot = Buffer.from(\n          await browser.takeScreenshot(),\n          'base64'\n        );\n        assetsToUpload.push([\n          'failure_screenshot.png',\n          AssetType.FAILURE_SCREENSHOT,\n          screenshot,\n        ]);\n      }\n      assetsToUpload.push([\n        'page_source.html',\n        AssetType.PAGE_SOURCE,\n        Buffer.from(await browser.getPageSource()),\n      ]);\n      assetsToUpload.push([\n        'console_log.txt',\n        AssetType.CONSOLE_LOG,\n        Buffer.from(APPLAUSE_LOG_RECORDS.getLogs().join('\\n')),\n      ]);\n\n      await Promise.allSettled(\n        assetsToUpload.map(([name, type, data]) =>\n          this.reporter.attachTestCaseAsset(\n            resultId,\n            name,\n            browser.sessionId,\n            type,\n            data\n          )\n        )\n      );\n    } catch (e) {\n      this.logger.error('Error capturing assets');\n      this.logger.error(e);\n    }\n  }\n\n  cleanErrorMessage(str?: string): string | undefined {\n    return str?.replace(/\\\\x1B\\[[0-9;]*[a-zA-Z]/g, '');\n}\n}\n\nexport class ApplausePlatformWdioReporter extends WDIOReporter {\n  private publciApi: PublicApi;\n  private config: ApplauseConfig;\n  private inflightCalls: Promise<unknown>[] = [];\n  private logger: winston.Logger;\n\n  constructor(options: Partial<ApplauseConfig & { logger: winston.Logger }>) {\n    super({ stdout: true, ...options });\n    this.config = loadConfig({\n      properties: options,\n    });\n    this.logger =\n      (options.logger as winston.Logger) || constructDefaultLogger();\n    // Setup the initial maps\n    this.publciApi = new PublicApi(this.config, this.logger);\n  }\n\n  onTestPass(test: TestStats): void {\n    const applauseTestCaseId = parseTestCaseName(\n      test.fullTitle\n    ).applauseTestCaseId;\n    if (applauseTestCaseId !== undefined) {\n      this.logger.info(`Test ${test.fullTitle}(${applauseTestCaseId}) passed`);\n      const caps = browser.capabilities;\n      this.inflightCalls.push(\n        this.publciApi.submitResult(Number(applauseTestCaseId), {\n          testCycleId: this.config.applauseTestCycleId!,\n          status: TestRunAutoResultStatus.PASSED,\n          sessionDetailsJson: {\n            value: {\n              deviceName: caps['appium:deviceName'],\n              orientation: caps['appium:orientation'],\n              platformName: caps.platformName,\n              platformVersion: caps['appium:platformVersion'],\n              browserName: caps.browserName,\n              browserVersion: caps.browserVersion,\n            },\n          },\n        })\n      );\n    }\n  }\n\n  onTestFail(test: TestStats): void {\n    const applauseTestCaseId = parseTestCaseName(\n      test.fullTitle\n    ).applauseTestCaseId;\n    if (applauseTestCaseId !== undefined) {\n      this.logger.info(`Test ${test.fullTitle}(${applauseTestCaseId}) failed`);\n      const caps = browser.capabilities;\n      this.inflightCalls.push(\n        this.publciApi.submitResult(Number(applauseTestCaseId), {\n          testCycleId: this.config.applauseTestCycleId!,\n          status: TestRunAutoResultStatus.FAILED,\n          sessionDetailsJson: {\n            value: {\n              deviceName: caps['appium:deviceName'],\n              orientation: caps['appium:orientation'],\n              platformName: caps.platformName,\n              platformVersion: caps['appium:platformVersion'],\n              browserName: caps.browserName,\n              browserVersion: caps.browserVersion,\n            },\n          },\n        })\n      );\n    }\n  }\n\n  onTestSkip(test: TestStats): void {\n    const applauseTestCaseId = parseTestCaseName(\n      test.fullTitle\n    ).applauseTestCaseId;\n    if (applauseTestCaseId !== undefined) {\n      this.logger.info(`Test ${test.fullTitle}(${applauseTestCaseId}) skipped`);\n      const caps = browser.capabilities;\n      this.inflightCalls.push(\n        this.publciApi.submitResult(Number(applauseTestCaseId), {\n          testCycleId: this.config.applauseTestCycleId!,\n          status: TestRunAutoResultStatus.SKIPPED,\n          sessionDetailsJson: {\n            value: {\n              deviceName: caps['appium:deviceName'],\n              orientation: caps['appium:orientation'],\n              platformName: caps.platformName,\n              platformVersion: caps['appium:platformVersion'],\n              browserName: caps.browserName,\n              browserVersion: caps.browserVersion,\n            },\n          },\n        })\n      );\n    }\n  }\n\n  async onRunnerEnd(): Promise<void> {\n    void (await Promise.all(this.inflightCalls));\n  }\n\n  get isSynchronised(): boolean {\n    return this.publciApi.getCallsInFlight === 0;\n  }\n}\n\nexport class ApplauseSkip extends Error {\n  readonly message: string;\n\n  constructor(message: string) {\n    super(\"ApplauseSkip: \" + message);\n    this.message = message;\n  }\n}\n\nexport function skip(message: string) {\n  throw new ApplauseSkip(message);\n}\n"],"names":["ApplauseSkip","Error","message","constructor","super","this","WDIOReporter","publciApi","config","inflightCalls","logger","options","stdout","loadConfig","properties","constructDefaultLogger","PublicApi","onTestPass","test","applauseTestCaseId","parseTestCaseName","fullTitle","undefined","info","caps","browser","capabilities","push","submitResult","Number","testCycleId","applauseTestCycleId","status","TestRunAutoResultStatus","PASSED","sessionDetailsJson","value","deviceName","orientation","platformName","platformVersion","browserName","browserVersion","onTestFail","FAILED","onTestSkip","SKIPPED","onRunnerEnd","Promise","all","isSynchronised","getCallsInFlight","reporter","activeTest","serviceOptions","ApplauseReporter","beforeTest","title","lookupTitle","startTestCase","providerSessionIds","beforeScenario","world","afterCommand","commandName","args","result","startsWith","screenshotName","split","pop","debug","attachTestCaseAsset","sessionId","AssetType","SCREENSHOT","Buffer","from","afterTest","_context","errorMessage","error","exception","passed","TestResultStatus","pending","warn","submitTestCaseResult","failureReason","cleanErrorMessage","providerSessionGuids","captureAssets","afterScenario","fullName","parent","pickle","name","resultId","assetsToUpload","screenshot","takeScreenshot","FAILURE_SCREENSHOT","PAGE_SOURCE","getPageSource","CONSOLE_LOG","APPLAUSE_LOG_RECORDS","getLogs","join","allSettled","map","type","data","e","str","replace","onPrepare","testRunId","runnerStart","process","env","onComplete","runnerEnd"],"mappings":"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"}