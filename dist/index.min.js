!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("@wdio/reporter"),require("auto-api-client-js"),require("fs"),require("path")):"function"==typeof define&&define.amd?define(["exports","@wdio/reporter","auto-api-client-js","fs","path"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self)["wdio-applause-reporter"]={},t.WDIOReporter,t.autoApiClientJs,t.fs,t.path)}(this,(function(t,e,s,i,o){"use strict";function n(t){return t&&"object"==typeof t&&"default"in t?t:{default:t}}var a=n(e);class r extends a.default{constructor(t){const e={stdout:!0,...t};super(e),this.contructorPassedOptions=e,this.uidToResultIdMap={}}get isSynchronised(){return void 0!==this.autoapi&&0===this.autoapi.getCallsInFlight}onRunnerStart(t){const e=t.config.capabilities["applause:options"],i=r.getExplanationForConfigOptionsLoadedFromMultiplePlaces({options:e,source:"capabilities"},{options:this.contructorPassedOptions,source:"Reporter construction"});if(void 0!==i)throw new Error(`Differing configuration options detected: ${i}`);const o={...e,...this.contructorPassedOptions};if(void 0===o.baseUrl)throw new Error("baseUrl is required");if(void 0===o.apiKey)throw new Error("apiKey is required");if(void 0===o.productId)throw new Error("productId is required");this.autoapi=new s.AutoApi({clientConfig:{baseUrl:o.baseUrl,apiKey:o.apiKey},productId:o.productId})}static getExplanationForConfigOptionsLoadedFromMultiplePlaces(...t){const e=r.getDuplicates(t.map((t=>t.source)));if(e.length>0)throw new Error(`duplicate options sources, please make sure all options sources are named with unique string. Duplicates: {${e.join("\n")}}`);const s={};t.flat(1).forEach((t=>{Object.entries(t.options).forEach((e=>{const[i,o]=e,n=void 0===s[i]?{}:s[i];n[o]=t.source,s[i]=n}))}));const i=Object.entries(s).filter((t=>Object.keys(t[1]).length>1)).map((t=>{const[e,s]=t,i=Object.entries(s).map((t=>{const[e,s]=t;return`\t\tSet to '${e}' in '${s}'`})).join("\n");return`Config Option '${e}' has multiple values! \n ${i}`})).join("\n");return i.length>0?i:void 0}static getDuplicates(t){const e=t.map((t=>({count:1,name:t}))).reduce(((t,e)=>(t[e.name]=(t[e.name]||0)+e.count,t)),{});return Object.keys(e).filter((t=>e[t]>1))}onTestStart(t){this.uidToResultIdMap[t.uid]=this.autoapi.startTestCase(t.title,browser.sessionId).then((t=>t.data.testResultId))}async onTestPass(t){const e=await this.uidToResultIdMap[t.uid];await this.autoapi.submitTestResult(e,s.TestResultStatus.PASSED)}async onTestFail(t){const e=await this.uidToResultIdMap[t.uid];await this.autoapi.submitTestResult(e,s.TestResultStatus.FAILED)}async onTestRetry(t){const e=await this.uidToResultIdMap[t.uid];await this.autoapi.submitTestResult(e,s.TestResultStatus.SKIPPED)}async onTestSkip(t){const e=await this.uidToResultIdMap[t.uid];await this.autoapi.submitTestResult(e,s.TestResultStatus.SKIPPED)}async onRunnerEnd(t){const e=Object.values(this.uidToResultIdMap);let s=[];await Promise.all(e).then((t=>s=null==t?[]:t)).catch((()=>console.error("Unable to retrieve Applause TestResultIds")));const n=(await this.autoapi.getProviderSessionLinks(s)).data||[];if(n.length>0){console.info(JSON.stringify(n));const e=t.config.outputDir||".";i.writeFileSync(o.join(e,"providerUrls.txt"),JSON.stringify(n,null,1))}}}t.ApplauseReporter=r,Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=index.min.js.map
